
atividade5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  0000023e  000002d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000023e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000006  0080010e  0080010e  000002e0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000002e0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000310  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000058  00000000  00000000  00000350  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000082d  00000000  00000000  000003a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000006a8  00000000  00000000  00000bd5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000349  00000000  00000000  0000127d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000007c  00000000  00000000  000015c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003bd  00000000  00000000  00001644  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000092  00000000  00000000  00001a01  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000028  00000000  00000000  00001a93  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 c5 00 	jmp	0x18a	; 0x18a <__vector_1>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 ea 00 	jmp	0x1d4	; 0x1d4 <__vector_4>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee e3       	ldi	r30, 0x3E	; 62
  7c:	f2 e0       	ldi	r31, 0x02	; 2
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 30       	cpi	r26, 0x0E	; 14
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	ae e0       	ldi	r26, 0x0E	; 14
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a4 31       	cpi	r26, 0x14	; 20
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 a1 00 	call	0x142	; 0x142 <main>
  9e:	0c 94 1d 01 	jmp	0x23a	; 0x23a <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <atraso>:

	.global atraso

atraso:

	push r30
  a6:	ef 93       	push	r30
	push r31
  a8:	ff 93       	push	r31

	/*Caso o Parametro seja zero, terminar a execução da rotina*/
	sbiw r24, 0
  aa:	00 97       	sbiw	r24, 0x00	; 0
	breq fim
  ac:	41 f0       	breq	.+16     	; 0xbe <fim>

000000ae <start>:

start: 
	ldi r30, 124
  ae:	ec e7       	ldi	r30, 0x7C	; 124
	ldi r31, 12
  b0:	fc e0       	ldi	r31, 0x0C	; 12

000000b2 <loop>:
	loop:
	sbiw  z, 1
  b2:	31 97       	sbiw	r30, 0x01	; 1
	breq inicio
  b4:	09 f0       	breq	.+2      	; 0xb8 <inicio>
	rjmp loop
  b6:	fd cf       	rjmp	.-6      	; 0xb2 <loop>

000000b8 <inicio>:

inicio:
	sbiw r24, 1
  b8:	01 97       	sbiw	r24, 0x01	; 1
	breq fim
  ba:	09 f0       	breq	.+2      	; 0xbe <fim>
	rjmp start
  bc:	f8 cf       	rjmp	.-16     	; 0xae <start>

000000be <fim>:

fim:
	/*Retirar da pilha e terminar a execução*/
	pop r31
  be:	ff 91       	pop	r31
	pop r30
  c0:	ef 91       	pop	r30
	RET
  c2:	08 95       	ret

000000c4 <cor_led>:
}

/*rotina de serviços relacionada a mudança de cor do led RGB*/
int cor_led(){
	
	if(sentido == 0){
  c4:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <sentido>
  c8:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <sentido+0x1>
  cc:	00 97       	sbiw	r24, 0x00	; 0
  ce:	91 f4       	brne	.+36     	; 0xf4 <cor_led+0x30>
		posicao = (posicao+1)%8;		
  d0:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <posicao>
  d4:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <posicao+0x1>
  d8:	01 96       	adiw	r24, 0x01	; 1
  da:	87 70       	andi	r24, 0x07	; 7
  dc:	90 78       	andi	r25, 0x80	; 128
  de:	99 23       	and	r25, r25
  e0:	24 f4       	brge	.+8      	; 0xea <cor_led+0x26>
  e2:	01 97       	sbiw	r24, 0x01	; 1
  e4:	88 6f       	ori	r24, 0xF8	; 248
  e6:	9f 6f       	ori	r25, 0xFF	; 255
  e8:	01 96       	adiw	r24, 0x01	; 1
  ea:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <posicao+0x1>
  ee:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <posicao>
  f2:	13 c0       	rjmp	.+38     	; 0x11a <cor_led+0x56>
	}
		
	else if(sentido == 1){
  f4:	01 97       	sbiw	r24, 0x01	; 1
  f6:	89 f4       	brne	.+34     	; 0x11a <cor_led+0x56>
		posicao = posicao - 1;
  f8:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <posicao>
  fc:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <posicao+0x1>
 100:	01 97       	sbiw	r24, 0x01	; 1
 102:	28 f0       	brcs	.+10     	; 0x10e <cor_led+0x4a>
 104:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <posicao+0x1>
 108:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <posicao>
 10c:	06 c0       	rjmp	.+12     	; 0x11a <cor_led+0x56>
		
		if(posicao == -1)
			posicao = 7;
 10e:	87 e0       	ldi	r24, 0x07	; 7
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <posicao+0x1>
 116:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <posicao>
	}
		
	*pt_portb = *pt_portb & 0x00;
 11a:	e0 91 0a 01 	lds	r30, 0x010A	; 0x80010a <pt_portb>
 11e:	f0 91 0b 01 	lds	r31, 0x010B	; 0x80010b <pt_portb+0x1>
 122:	10 82       	st	Z, r1
	*pt_portb = *pt_portb | cores[posicao];
 124:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <pt_portb>
 128:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <pt_portb+0x1>
 12c:	e0 91 10 01 	lds	r30, 0x0110	; 0x800110 <posicao>
 130:	f0 91 11 01 	lds	r31, 0x0111	; 0x800111 <posicao+0x1>
 134:	e0 50       	subi	r30, 0x00	; 0
 136:	ff 4f       	sbci	r31, 0xFF	; 255
 138:	9c 91       	ld	r25, X
 13a:	80 81       	ld	r24, Z
 13c:	89 2b       	or	r24, r25
 13e:	8c 93       	st	X, r24
}
 140:	08 95       	ret

00000142 <main>:

int main(void)
{
	
	/*Configurar pinos 0-2 de B como saída*/
	*pt_ddrb = *pt_ddrb | 0x07;
 142:	e0 91 0c 01 	lds	r30, 0x010C	; 0x80010c <pt_ddrb>
 146:	f0 91 0d 01 	lds	r31, 0x010D	; 0x80010d <pt_ddrb+0x1>
 14a:	80 81       	ld	r24, Z
 14c:	87 60       	ori	r24, 0x07	; 7
 14e:	80 83       	st	Z, r24
	
	//Configurar interrupção externa do INT0 por borda de subida
	EICRA |= (1 << ISC00);
 150:	e9 e6       	ldi	r30, 0x69	; 105
 152:	f0 e0       	ldi	r31, 0x00	; 0
 154:	80 81       	ld	r24, Z
 156:	81 60       	ori	r24, 0x01	; 1
 158:	80 83       	st	Z, r24
	EICRA |= (1 << ISC01);
 15a:	80 81       	ld	r24, Z
 15c:	82 60       	ori	r24, 0x02	; 2
 15e:	80 83       	st	Z, r24
	EIMSK |= (1 << INT0);
 160:	e8 9a       	sbi	0x1d, 0	; 29
	
	//Habilitar interrupção externa tipo PIN Change do PCINT8 associado ao PCIE1
	PCICR |= (1 << PCIE1);
 162:	e8 e6       	ldi	r30, 0x68	; 104
 164:	f0 e0       	ldi	r31, 0x00	; 0
 166:	80 81       	ld	r24, Z
 168:	82 60       	ori	r24, 0x02	; 2
 16a:	80 83       	st	Z, r24
	PCMSK1 |= (1 << PCINT8);
 16c:	ec e6       	ldi	r30, 0x6C	; 108
 16e:	f0 e0       	ldi	r31, 0x00	; 0
 170:	80 81       	ld	r24, Z
 172:	81 60       	ori	r24, 0x01	; 1
 174:	80 83       	st	Z, r24
	

	//Habilitar todas as interrupções
	sei();
 176:	78 94       	sei
	
	while (1) 
    {
		/*Aqui chamamos a rotina de atraso*/
		atraso(atrasar);
 178:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <atrasar>
 17c:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <atrasar+0x1>
 180:	0e 94 53 00 	call	0xa6	; 0xa6 <atraso>
		/*Aqui chamamos a rotina que muda o estado do LED RGB*/
		cor_led();
 184:	0e 94 62 00 	call	0xc4	; 0xc4 <cor_led>
 188:	f7 cf       	rjmp	.-18     	; 0x178 <main+0x36>

0000018a <__vector_1>:
}


/*rotina de serviço relacionada à interrupção INT0, para diminuir pela metade o tempo de mudança de cor*/
ISR (INT0_vect)
{
 18a:	1f 92       	push	r1
 18c:	0f 92       	push	r0
 18e:	0f b6       	in	r0, 0x3f	; 63
 190:	0f 92       	push	r0
 192:	11 24       	eor	r1, r1
 194:	8f 93       	push	r24
 196:	9f 93       	push	r25
	atrasar = atrasar / 2;
 198:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <atrasar>
 19c:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <atrasar+0x1>
 1a0:	99 23       	and	r25, r25
 1a2:	0c f4       	brge	.+2      	; 0x1a6 <__vector_1+0x1c>
 1a4:	01 96       	adiw	r24, 0x01	; 1
 1a6:	95 95       	asr	r25
 1a8:	87 95       	ror	r24
	
	if (atrasar < 100)
 1aa:	84 36       	cpi	r24, 0x64	; 100
 1ac:	91 05       	cpc	r25, r1
 1ae:	2c f0       	brlt	.+10     	; 0x1ba <__vector_1+0x30>


/*rotina de serviço relacionada à interrupção INT0, para diminuir pela metade o tempo de mudança de cor*/
ISR (INT0_vect)
{
	atrasar = atrasar / 2;
 1b0:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <atrasar+0x1>
 1b4:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <atrasar>
 1b8:	06 c0       	rjmp	.+12     	; 0x1c6 <__vector_1+0x3c>
	
	if (atrasar < 100)
		atrasar = 1000;
 1ba:	88 ee       	ldi	r24, 0xE8	; 232
 1bc:	93 e0       	ldi	r25, 0x03	; 3
 1be:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <atrasar+0x1>
 1c2:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <atrasar>
			
}
 1c6:	9f 91       	pop	r25
 1c8:	8f 91       	pop	r24
 1ca:	0f 90       	pop	r0
 1cc:	0f be       	out	0x3f, r0	; 63
 1ce:	0f 90       	pop	r0
 1d0:	1f 90       	pop	r1
 1d2:	18 95       	reti

000001d4 <__vector_4>:

/*rotina de serviço relacionada à interrupção PCINT8, para inverter o sentido de acionamento das cores do led RGB*/
ISR (PCINT1_vect)
{
 1d4:	1f 92       	push	r1
 1d6:	0f 92       	push	r0
 1d8:	0f b6       	in	r0, 0x3f	; 63
 1da:	0f 92       	push	r0
 1dc:	11 24       	eor	r1, r1
 1de:	8f 93       	push	r24
 1e0:	9f 93       	push	r25
	if (pressionado == 0)
 1e2:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <__data_end>
 1e6:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <__data_end+0x1>
 1ea:	89 2b       	or	r24, r25
 1ec:	69 f4       	brne	.+26     	; 0x208 <__vector_4+0x34>
		pressionado = 1;
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	90 e0       	ldi	r25, 0x00	; 0
 1f2:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <__data_end+0x1>
 1f6:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <__data_end>
	else
		pressionado = 0;	
	
	if (pressionado == 1){
		if(sentido == 0)
 1fa:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <sentido>
 1fe:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <sentido+0x1>
 202:	00 97       	sbiw	r24, 0x00	; 0
 204:	69 f4       	brne	.+26     	; 0x220 <__vector_4+0x4c>
 206:	05 c0       	rjmp	.+10     	; 0x212 <__vector_4+0x3e>
ISR (PCINT1_vect)
{
	if (pressionado == 0)
		pressionado = 1;
	else
		pressionado = 0;	
 208:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <__data_end+0x1>
 20c:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <__data_end>
 210:	0d c0       	rjmp	.+26     	; 0x22c <__vector_4+0x58>
	
	if (pressionado == 1){
		if(sentido == 0)
			sentido = 1;
 212:	81 e0       	ldi	r24, 0x01	; 1
 214:	90 e0       	ldi	r25, 0x00	; 0
 216:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <sentido+0x1>
 21a:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <sentido>
 21e:	06 c0       	rjmp	.+12     	; 0x22c <__vector_4+0x58>
		
		else if(sentido == 1)
 220:	01 97       	sbiw	r24, 0x01	; 1
 222:	21 f4       	brne	.+8      	; 0x22c <__vector_4+0x58>
			sentido = 0;
 224:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <sentido+0x1>
 228:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <sentido>
	}
}
 22c:	9f 91       	pop	r25
 22e:	8f 91       	pop	r24
 230:	0f 90       	pop	r0
 232:	0f be       	out	0x3f, r0	; 63
 234:	0f 90       	pop	r0
 236:	1f 90       	pop	r1
 238:	18 95       	reti

0000023a <_exit>:
 23a:	f8 94       	cli

0000023c <__stop_program>:
 23c:	ff cf       	rjmp	.-2      	; 0x23c <__stop_program>
